<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ZACMAN — WebApp Geolocalizada (Leaflet + Calles)</title>
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha384-o9dC1Xg6Kqv4Qp3q8T4YQxvDqVqJq4c2Q2nZ9l9o1p2jYq3K6xZk1Fq0K1s4u2y5" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- tinyqueue for A* performance -->
  <script src="https://unpkg.com/tinyqueue@2.0.3/tinyqueue.min.js"></script>
  <style>
    :root{
      --color-bg: #1a0d0d;
      --color-card: #2b0f0f;
      --color-text: #f2f2f2;
      --color-muted: #b3a9a9;
      --color-red: #c92222;
      --color-red-dark: #8a1a1a;
      --color-green: #6abf4b;
      --color-yellow: #ffd166;
      --shadow: 0 10px 30px rgba(0,0,0,.5);
    }
    *{box-sizing:border-box}
    html,body,#app{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--color-bg);color:var(--color-text)}
    header{display:flex;align-items:center;justify-content:space-between;padding:10px 14px;background:linear-gradient(180deg,#230d0d,#180909);border-bottom:1px solid rgba(0,0,0,.4)}
    .brand{display:flex;align-items:center;gap:10px;font-weight:800}
    .logo{width:36px;height:36px;border-radius:8px;background:linear-gradient(180deg,var(--color-red),#7f0f0f);box-shadow:0 4px 14px rgba(201,34,34,.2);display:flex;align-items:center;justify-content:center;font-weight:900;color:white}
    main{display:flex;height:calc(100% - 62px)}
    #map{flex:1}
    aside{width:340px;padding:12px;background:var(--color-card);border-left:1px solid rgba(0,0,0,.4);box-shadow:var(--shadow);overflow:auto}
    .panel{display:flex;flex-direction:column;gap:10px}
    .row{display:flex;gap:8px;align-items:center}
    .stat{background:#140606;border:1px solid rgba(255,255,255,.02);padding:10px;border-radius:10px;flex:1}
    button{cursor:pointer;border:none;background:var(--color-red);color:white;border-radius:10px;padding:10px 12px;font-weight:700}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,.06)}
    .toggle.active{background:var(--color-green)}
    small{color:var(--color-muted)}
    #log{height:240px;overflow:auto;background:#120606;padding:8px;border-radius:8px;font-size:13px}
    .control{display:flex;flex-direction:column;gap:6px}
    .control label{font-size:13px}
    .divider{height:1px;background:rgba(255,255,255,.03);margin:8px 0}

    /* Leaflet tweaks */
    .leaflet-control-container .leaflet-top.leaflet-left{margin-top:62px}

    /* Mobile */
    @media (max-width:980px){ aside{width:100%;height:360px;position:fixed;bottom:0;left:0;right:0;z-index:999;border-left:none;border-top:1px solid rgba(0,0,0,.4)} main{flex-direction:column} }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <div class="brand"><div class="logo">Z</div><div>ZAC<b>MAN</b> <small style="margin-left:8px;color:var(--color-muted)">Playtest</small></div></div>
      <div class="row">
        <button id="btnStart">▶ Empezar</button>
        <button id="btnReset" class="secondary">↺ Reiniciar</button>
      </div>
    </header>

    <main>
      <div id="map"></div>
      <aside>
        <div class="panel">
          <div class="row">
            <div class="stat">Puntuación: <b id="uiScore">0</b></div>
            <div class="stat">Suministros: <b id="uiSupplies">0/0</b></div>
          </div>
          <div class="row">
            <div class="stat">Salud: <b id="uiHealth">100</b></div>
            <div class="stat">Power: <b id="uiPower">—</b></div>
          </div>

          <div class="divider"></div>

          <div class="control">
            <label><input type="checkbox" id="chkMock"> Activar Modo Mock (WASD)</label>
            <label><input type="checkbox" id="chkShowGraph" checked> Mostrar red de calles (depuración)</label>
          </div>

          <div class="row">
            <button id="btnSpawn">+ Zombies</button>
            <button id="btnPower">Activar Power</button>
          </div>

          <div class="divider"></div>

          <div id="log"></div>

          <small>Consejos: en móvil otorga permiso de ubicación para que el jugador se mueva por la ciudad. Los zombies buscarán rutas por la red de calles (OSM) y no atravesarán edificios.</small>
        </div>
      </aside>
    </main>
  </div>

  <script>
  // -------------------- UTILIDADES --------------------
  const toRad = d => d*Math.PI/180;
  const toDeg = r => r*180/Math.PI;
  function haversine(a,b){ const R=6371000; const dLat=toRad(b.lat-a.lat), dLon=toRad(b.lon-a.lon); const lat1=toRad(a.lat), lat2=toRad(b.lat); const s=Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2; return 2*R*Math.asin(Math.sqrt(s)); }
  function log(msg){ const el=document.getElementById('log'); el.innerHTML = `<div>${new Date().toLocaleTimeString()} — ${msg}</div>` + el.innerHTML; }

  // -------------------- ESTADO --------------------
  const state = {
    running:false,
    mock:false,
    mapCenter: {lat:40.4168, lon:-3.7038}, // Madrid fallback
    player: {lat:null, lon:null, x:0,y:0, health:100, power:0},
    zombies:[], supplies:[], powerups:[], score:0, collected:0, total:0,
    osmGraph: {nodes:{}, adj:{}}, // graph derived from OSM ways
    showGraph: true,
  };

  const ui = {
    score: document.getElementById('uiScore'),
    supplies: document.getElementById('uiSupplies'),
    health: document.getElementById('uiHealth'),
    power: document.getElementById('uiPower'),
  };

  // -------------------- MAPA (Leaflet) --------------------
  const map = L.map('map', {preferCanvas:true}).setView([state.mapCenter.lat, state.mapCenter.lon], 16);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(map);

  // Layers
  const layerRoads = L.layerGroup().addTo(map);
  const layerZombies = L.layerGroup().addTo(map);
  const layerSupplies = L.layerGroup().addTo(map);
  const layerPlayer = L.layerGroup().addTo(map);

  // Player marker
  const playerMarker = L.circleMarker([state.mapCenter.lat, state.mapCenter.lon], {radius:8,color: '#c92222', fill:true, fillColor:'#c92222'}).addTo(layerPlayer);

  // -------------------- GEOLOCALIZACIÓN --------------------
  let watchId = null;
  function startGeo(){
    if(!navigator.geolocation){ log('Geolocalización no soportada en este navegador'); return; }
    watchId = navigator.geolocation.watchPosition(p=>{
      state.player.lat = p.coords.latitude; state.player.lon = p.coords.longitude;
      playerMarker.setLatLng([state.player.lat, state.player.lon]);
      map.panTo([state.player.lat, state.player.lon], {animate:true, duration:0.6});
    }, err=>{
      log('Error geo: ' + err.message);
    }, {enableHighAccuracy:true, maximumAge:1000, timeout:10000});
  }

  // -------------------- OSM: descargar red de calles (Overpass) --------------------
  // construye grafo de nodos y adyacencias a partir de ways tipo highway (respetando edificios implícitos)
  async function fetchOSMGraph(center, radiusMeters=400){
    const lat=center.lat, lon=center.lon; // Overpass bbox approx: create around center
    // Overpass query: fetch ways highway within radius
    const q = `[out:json][timeout:25];(way(around:${radiusMeters},${lat},${lon})[highway];>;);out;`;
    const url = 'https://overpass-api.de/api/interpreter';
    log('Descargando red OSM...');
    const res = await fetch(url, {method:'POST', body:q});
    const json = await res.json();
    // construir nodos
    const nodes = {}; const ways = [];
    for(const el of json.elements){
      if(el.type==='node') nodes[el.id] = {id:el.id, lat:el.lat, lon:el.lon};
      if(el.type==='way') ways.push(el);
    }

    // construir adyacencias
    const adj = {};
    for(const w of ways){
      const nds = w.nodes;
      for(let i=0;i<nds.length-1;i++){
        const a = nds[i], b=nds[i+1];
        if(!nodes[a]||!nodes[b]) continue;
        adj[a] = adj[a] || new Set(); adj[b] = adj[b] || new Set();
        adj[a].add(b); adj[b].add(a);
      }
    }

    // convertir sets a arrays
    const adjArr = {}; for(const k in adj) adjArr[k] = Array.from(adj[k]);
    state.osmGraph = {nodes, adj: adjArr};
    log(`Grafo OSM: ${Object.keys(nodes).length} nodos, ${ways.length} ways`);
    drawGraph();
  }

  function drawGraph(){ layerRoads.clearLayers();
    if(!state.showGraph) return;
    const nodes = state.osmGraph.nodes; const adj = state.osmGraph.adj;
    // dibuja edges
    for(const a in adj){ for(const b of adj[a]){
      const A = nodes[a], B = nodes[b]; if(!A||!B) continue;
      L.polyline([[A.lat,A.lon],[B.lat,B.lon]], {color:'#6b2b2b', weight:2, opacity:0.6}).addTo(layerRoads);
    }}
  }

  // -------------------- PATHFINDING (A* sobre nodos) --------------------
  function nearestNode(lat,lon){ // busca nodo OSM más cercano
    let best = null; let bestD = Infinity;
    for(const id in state.osmGraph.nodes){ const n = state.osmGraph.nodes[id]; const d = haversine({lat,lon}, n); if(d<bestD){ bestD=d; best=n; }}
    return best;
  }

  function astarPath(startId, goalId){
    if(!startId || !goalId) return null;
    const nodes = state.osmGraph.nodes; const adj = state.osmGraph.adj;
    const open = new TinyQueue([], (a,b)=>a.f-b.f);
    const gscore = {}; const fscore = {}; const cameFrom = {};
    gscore[startId]=0; fscore[startId]=heur(startId, goalId); open.push({id:startId,f:fscore[startId]});
    while(open.length){ const cur = open.pop().id; if(cur==goalId){ // reconstruct
        const path=[]; let u=cur; while(u){ path.push(u); u=cameFrom[u]; } return path.reverse(); }
      const neighbors = adj[cur] || [];
      for(const nb of neighbors){ const tentative = gscore[cur] + haversine(nodes[cur], nodes[nb]);
        if(tentative < (gscore[nb]||Infinity)){ cameFrom[nb]=cur; gscore[nb]=tentative; fscore[nb]=tentative+heur(nb,goalId); if(!open.data.find(x=>x.id==nb)) open.push({id:nb,f:fscore[nb]}); }
      }
    }
    return null;
  }
  function heur(a,b){ const na=state.osmGraph.nodes[a], nb=state.osmGraph.nodes[b]; return haversine(na,nb); }

  // -------------------- SPAWN: zombies, supplies sobre nodos --------------------
  function spawnSuppliesOnRoads(count=20){ state.supplies=[]; layerSupplies.clearLayers(); const nodeIds = Object.keys(state.osmGraph.nodes);
    for(let i=0;i<count;i++){ const nid = nodeIds[Math.floor(Math.random()*nodeIds.length)]; const n = state.osmGraph.nodes[nid]; const marker = L.circleMarker([n.lat,n.lon], {radius:6, color: '#c92222', fill:true, fillColor:'#c92222'}).addTo(layerSupplies);
      state.supplies.push({node: nid, taken:false, marker}); }
    state.total = state.supplies.length; updateUI(); }

  function spawnZombiesOnRoads(count=6){ state.zombies=[]; layerZombies.clearLayers(); const nodeIds = Object.keys(state.osmGraph.nodes);
    for(let i=0;i<count;i++){ const nid = nodeIds[Math.floor(Math.random()*nodeIds.length)]; const n = state.osmGraph.nodes[nid]; const marker = L.circleMarker([n.lat,n.lon], {radius:8, color:'#6abf4b', fill:true, fillColor:'#6abf4b'}).addTo(layerZombies);
      state.zombies.push({node: nid, lat:n.lat, lon:n.lon, marker, path:[], speed:1.0 + Math.random()*0.6, idxOnPath:0}); }
    updateUI(); }

  // -------------------- ZOMBIE AI: camino por nodos hacia el jugador --------------------
  async function updateZombiesTargets(){ if(!state.player.lat) return; const targetNode = nearestNode(state.player.lat, state.player.lon); if(!targetNode) return;
    for(const z of state.zombies){ const path = astarPath(z.node, targetNode.id); if(path && path.length>1){ z.path = path; z.idxOnPath = 0; } }
  }

  function stepZombies(dt){ // mueve los zombies a lo largo del path (interpolando entre nodos)
    const nodes = state.osmGraph.nodes;
    for(const z of state.zombies){ if(!z.path || z.path.length<2) continue; const curId = z.path[z.idxOnPath]; const nextId = z.path[z.idxOnPath+1]; if(!nextId) continue;
      const A = nodes[curId], B = nodes[nextId]; const segLen = haversine(A,B);
      if(!z.progress) z.progress = 0;
      z.progress += z.speed * dt; // meters per second
      if(z.progress >= segLen){ // advance
        z.idxOnPath++; z.node = nextId; z.progress = z.progress - segLen; // clamp
        if(z.idxOnPath >= z.path.length-1){ z.path = []; z.progress=0; }
      }
      // compute interpolated lat/lon
      if(z.path && z.path.length>1){ const cur = nodes[z.path[z.idxOnPath]]; const nxt = nodes[z.path[z.idxOnPath+1]]; const ratio = Math.min(1, z.progress / Math.max(1e-6, haversine(cur,nxt)));
        z.lat = cur.lat + (nxt.lat - cur.lat)*ratio; z.lon = cur.lon + (nxt.lon - cur.lon)*ratio; z.marker.setLatLng([z.lat,z.lon]);
        // collision with player if very close
        if(state.player.lat && haversine({lat:z.lat,lon:z.lon},{lat:state.player.lat,lon:state.player.lon}) < 6){ state.player.health -= 10*dt; }
      }
    }
  }

  // -------------------- PICKUPS logic --------------------
  function checkPickups(){ if(!state.player.lat) return;
    for(const s of state.supplies){ if(s.taken) continue; const n = state.osmGraph.nodes[s.node]; if(haversine({lat:n.lat,lon:n.lon},{lat:state.player.lat,lon:state.player.lon}) < 6){ s.taken=true; s.marker.remove(); state.collected++; state.score += 50; log('Suministro recogido'); } }
    updateUI(); }

  // -------------------- UI / Loop --------------------
  function updateUI(){ ui.score.textContent = Math.floor(state.score); ui.supplies.textContent = `${state.collected}/${state.total}`; ui.health.textContent = Math.max(0, Math.floor(state.player.health)); ui.power.textContent = state.player.power>0? state.player.power.toFixed(1)+'s':'—'; }

  let last = performance.now();
  function loop(t){ const dt = Math.min(0.1, (t-last)/1000); last=t; if(state.running){ stepZombies(dt); updateUI(); checkPickups(); }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // -------------------- Controles UI --------------------
  document.getElementById('btnStart').onclick = async ()=>{
    if(state.running) return; state.running = true; log('Partida iniciada');
    // centrar y preparar grafo
    if(!state.player.lat){ // try immediate geolocation to center
      navigator.geolocation.getCurrentPosition(p=>{ state.player.lat=p.coords.latitude; state.player.lon=p.coords.longitude; map.setView([state.player.lat,state.player.lon], 17); fetchOSMGraph({lat:state.player.lat, lon:state.player.lon}, 600).then(()=>{ spawnSuppliesOnRoads(28); spawnZombiesOnRoads(8); updateZombiesTargets(); startGeo(); }); }, err=>{ log('No GPS: modo Mock'); fetchOSMGraph(state.mapCenter, 600).then(()=>{ spawnSuppliesOnRoads(28); spawnZombiesOnRoads(8); updateZombiesTargets(); }); });
    } else { await fetchOSMGraph({lat:state.player.lat, lon:state.player.lon}, 600); spawnSuppliesOnRoads(28); spawnZombiesOnRoads(8); updateZombiesTargets(); startGeo(); }
  };
  document.getElementById('btnReset').onclick = ()=>{ state.running=false; state.zombies=[]; state.supplies=[]; layerZombies.clearLayers(); layerSupplies.clearLayers(); log('Partida reiniciada'); };
  document.getElementById('btnSpawn').onclick = ()=>{ spawnZombiesOnRoads(4); updateZombiesTargets(); };
  document.getElementById('btnPower').onclick = ()=>{ state.player.power = 8; log('Power activado: Zombies lentos'); for(const z of state.zombies) z.speed *= 0.4; setTimeout(()=>{ for(const z of state.zombies) z.speed /= 0.4; state.player.power=0; log('Power terminado'); }, 8000); };
  document.getElementById('chkMock').addEventListener('change',(e)=>{ state.mock = e.target.checked; if(state.mock) enableMockControls(); else disableMockControls(); });
  document.getElementById('chkShowGraph').addEventListener('change',(e)=>{ state.showGraph = e.target.checked; drawGraph(); });

  // -------------------- Mock movement (keyboard) --------------------
  const keys = new Set(); function enableMockControls(){ window.addEventListener('keydown', onKey); window.addEventListener('keyup', onKeyUp); }
  function disableMockControls(){ window.removeEventListener('keydown', onKey); window.removeEventListener('keyup', onKeyUp); }
  function onKey(e){ keys.add(e.key.toLowerCase()); }
  function onKeyUp(e){ keys.delete(e.key.toLowerCase()); }
  setInterval(()=>{ if(state.mock){ let lat = state.player.lat || state.mapCenter.lat, lon = state.player.lon || state.mapCenter.lon; const step = 0.00012; if(keys.has('w')||keys.has('arrowup')) lat += step; if(keys.has('s')||keys.has('arrowdown')) lat -= step; if(keys.has('a')||keys.has('arrowleft')) lon -= step; if(keys.has('d')||keys.has('arrowright')) lon += step; state.player.lat = lat; state.player.lon = lon; playerMarker.setLatLng([lat,lon]); map.panTo([lat,lon]); updateZombiesTargets(); } }, 120);

  // -------------------- Update targets periodically --------------------
  setInterval(()=>{ if(state.running) updateZombiesTargets(); }, 3000);

  // -------------------- startGeo function reused --------------------
  function startGeo(){ if(!navigator.geolocation) return; navigator.geolocation.watchPosition(p=>{ state.player.lat=p.coords.latitude; state.player.lon=p.coords.longitude; playerMarker.setLatLng([state.player.lat,state.player.lon]); updateZombiesTargets(); }, err=>{ log('watchPosition: ' + err.message); }, {enableHighAccuracy:true}); }

  // -------------------- helpers for dev: center map on click to refetch graph --------------------
  map.on('contextmenu', e=>{ const ll = e.latlng; fetchOSMGraph({lat:ll.lat, lon:ll.lng}, 500).then(()=>{ spawnSuppliesOnRoads(24); spawnZombiesOnRoads(6); updateZombiesTargets(); map.setView([ll.lat,ll.lng]); log('Grafo recargado en el punto seleccionado'); }); });

  // -------------------- nota: persistencia simple --------------------
  window.addEventListener('beforeunload', ()=>{ localStorage.setItem('zacman.settings', JSON.stringify({showGraph:state.showGraph})); });
  const saved = JSON.parse(localStorage.getItem('zacman.settings') || '{}'); if(saved.showGraph===false) { state.showGraph=false; document.getElementById('chkShowGraph').checked=false; }

  </script>
</body>
</html>
